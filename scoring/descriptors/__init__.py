import numpy as np
from scipy.spatial.distance import cdist as distance

class Molecule
""" Class which holds dictionaries aiding descriptors calculation """
    
    def __init__(self, mol):
        """ mol: pybel molecule """
        self.m = mol
    
    def coordinate_dict(self, atomic_nums):
        """
        Returns vector of atomic coordinates of atoms with atomic number = atomic_num in given molecule 
        
        atomic nums: array of atomic numbers to compute the dictionary 
        """
        
        # define dictionaries
        mol_atoms = []
        for i in range(len(atomic_num)):
                mol_atoms.append([])
        # iterate through atoms
        for atom in mol:
                        if atom.atomicnum in atomic_num:
                                mol_atoms[atomic_num.index(atom.atomicnum)].append(atom.coords)
        return np.array(mol_atoms)


# DESCRIPTORS

def close_contact(mol1_atoms, mol2_atoms, cuttoff):
    """
    Builds descriptor from two dictionaries (protein and ligand) generated by mol_dict()
    """
    
    # !!! FIX: change to pure numpy implementation, but distance must support nested atom coordinates
    #return np.sum(distance(mol2_atoms, mol1_atoms) < cutoff, axis=-1)
    
    # !!! FIX 2: check if scipy.spatial.KDTree performs well, otherwise leave numpy alone
    f = []
    for mol2_num in range(mol1_atoms.shape[0]):
            for mol1_num in range(mol1_atoms.shape[0]):
                    if len(mol2_atoms[mol2_num]) > 0 and len(mol1_atoms[mol1_num]) > 0:
                            f.append(np.sum(distance(mol2_atoms[mol2_num], mol1_atoms[mol1_num]) < cutoff))
                    else:
                            f.append(0)
    return f
