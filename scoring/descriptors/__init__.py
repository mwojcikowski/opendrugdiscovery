import numpy as np
from scipy.spatial.distance import cdist

def distance(a,b):
    # catch nested (ligands + atomic number groups) coordinates of shape (m-ligands, k-groups, n-atoms, m-dim)
    if len(a.shape) == 3 and len(b.shape) == 4:
        return np.sqrt((b[:,np.newaxis,:,np.newaxis,:,0] - a[:, np.newaxis, :, 0, np.newaxis])**2 + (b[:,np.newaxis,:, np.newaxis,:,1] - a[:, np.newaxis, :, 1, np.newaxis])**2 + (b[:,np.newaxis,:, np.newaxis, :,2] - a[:, np.newaxis, :, 2, np.newaxis])**2)
    # catch nested coordinates of shape (k-groups, n-atoms, m-dim)
    if len(a.shape) == 3 and len(b.shape) == 3:
        return np.sqrt((b[:,np.newaxis,:,0] - a[:, np.newaxis, :, 0, np.newaxis])**2 + (b[:, np.newaxis,:,1] - a[:, np.newaxis, :, 1, np.newaxis])**2 + (b[:, np.newaxis, :,2] - a[:, np.newaxis, :, 2, np.newaxis])**2)
    # otherwise simple group of atom coordinates of shape (n-atoms, m-dim)
    elif len(a.shape) == 2 and len(b.shape) == 2:
        # numpy fastest solution (slower than scipy.spatial.distance.cdist)
        #return np.sqrt(((b[:,0] - a[:,0, np.newaxis])**2 + (b[:,1] - a[:,1, np.newaxis])**2 + (b[:,2] - a[:,2, np.newaxis])**2))
        # scipy
        return cdist(a,b)
    else:
        raise ValueError('Unsuported shape of arrays (%i, %i)' % (len(a.shape), len(b.shape)))

class Molecule:
    """ Class which holds dictionaries aiding descriptors calculation """
    def __init__(self, mol):
        """ mol: pybel molecule """
        self.m = mol
    
    def coordinate_dict(self, atomic_nums):
        """
        Returns vector of atomic coordinates of atoms with atomic number = atomic_num in given molecule 
        
        atomic nums: array of atomic numbers to compute the dictionary 
        """
        
        for a in atomic_nums:
        
        # define dictionaries
        mol_atoms = np.empty((len(atomic_nums), len(self.m.atoms),3))
        mol_atoms.fill(np.nan)
        # iterate through atoms
        for atom in self.m:
            if atom.atomicnum in atomic_nums:
                    mol_atoms[atomic_nums.index(atom.atomicnum)][atom.idx-1] = atom.coords
        return mol_atoms


# DESCRIPTORS

def close_contact(mol1_atoms, mol2_atoms, cutoff):
    """
    Builds descriptor from two dictionaries (protein and ligand) generated by mol_dict()
    """
    
    # !!! FIX: change to pure numpy implementation, but distance must support nested atom coordinates
    #return np.sum(distance(mol2_atoms, mol1_atoms) < cutoff, axis=-1)
    return np.sum(distance(mol1_atoms, mol2_atoms) < cutoff, axis=(-1,-2))
    # !!! FIX 2: check if scipy.spatial.KDTree performs well, otherwise leave numpy alone
#    f = []
#    for mol2_num in range(mol1_atoms.shape[0]):
#            for mol1_num in range(mol1_atoms.shape[0]):
#                    if len(mol2_atoms[mol2_num]) > 0 and len(mol1_atoms[mol1_num]) > 0:
#                            f.append(np.sum(distance(mol2_atoms[mol2_num], mol1_atoms[mol1_num]) < cutoff))
#                    else:
#                            f.append(0)
#    return f
